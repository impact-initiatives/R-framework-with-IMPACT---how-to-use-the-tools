[
  {
    "objectID": "02-cleaning/02-cleaning-02-create-clean-dataset.html",
    "href": "02-cleaning/02-cleaning-02-create-clean-dataset.html",
    "title": "02 - Crear un conjunto de datos limpios",
    "section": "",
    "text": "library(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices",
    "crumbs": [
      "Cleaning session 2",
      "02 - Crear un conjunto de datos limpios"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-02-create-clean-dataset.html#review_cleaning_log",
    "href": "02-cleaning/02-cleaning-02-create-clean-dataset.html#review_cleaning_log",
    "title": "02 - Crear un conjunto de datos limpios",
    "section": "review_cleaning_log",
    "text": "review_cleaning_log\nLa funcion review_cleaning_log revisa como se relleno el registro de limpieza.\n\nmy_filled_log &lt;- readxl::read_excel(\"../inputs/02 - example - cleaning-log-with-kobo - filled.xlsx\", sheet = 2)\n\ncheck_log_results &lt;- review_cleaning_log(raw_dataset = my_raw_dataset,\n                                        raw_data_uuid_column = \"X_uuid\",\n                                        cleaning_log = my_filled_log, \n                                        cleaning_log_uuid_column = \"uuid\",\n                                        cleaning_log_question_column = \"question\",\n                                        cleaning_log_new_value_column = \"new_value\",\n                                        cleaning_log_change_type_column = \"change_type\",\n                                        change_response_value = \"change_response\")\ncheck_log_results\n\n[1] \"no issues in cleaning log found\"",
    "crumbs": [
      "Cleaning session 2",
      "02 - Crear un conjunto de datos limpios"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-02-create-clean-dataset.html#create_clean_data",
    "href": "02-cleaning/02-cleaning-02-create-clean-dataset.html#create_clean_data",
    "title": "02 - Crear un conjunto de datos limpios",
    "section": "create_clean_data",
    "text": "create_clean_data\nPara crear el conjunto de datos limpio, la función create_clean_data necesita el conjunto de datos bruto y el registro de limpieza completado.\n\nmy_clean_data &lt;- create_clean_data(raw_dataset = my_raw_dataset,\n                                   raw_data_uuid_column = \"X_uuid\",\n                                   cleaning_log = my_filled_log, \n                                   cleaning_log_uuid_column = \"uuid\",\n                                   cleaning_log_question_column = \"question\",\n                                   cleaning_log_new_value_column = \"new_value\",\n                                   cleaning_log_change_type_column = \"change_type\")\n\n[1] \"water_supply_other_neighbourhoods_why\"\n[1] \"trust_water_office_why_not\"\n[1] \"pay_water_charges_amount\"\n[1] \"connection_fees_amount\"\n[1] \"connection_fees_amount\"\n[1] \"primary_livelihood.employment\"\n[1] \"primary_livelihood.employment\"\n[1] \"primary_livelihood.employment\"\n[1] \"tank_emptied\"\n[1] \"access_water_enough\"",
    "crumbs": [
      "Cleaning session 2",
      "02 - Crear un conjunto de datos limpios"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-02-create-clean-dataset.html#recreate_parent_column",
    "href": "02-cleaning/02-cleaning-02-create-clean-dataset.html#recreate_parent_column",
    "title": "02 - Crear un conjunto de datos limpios",
    "section": "recreate_parent_column",
    "text": "recreate_parent_column\nEn el siguiente ejemplo, en el registro de limpieza, se modifican ciertas columnas de opción multiple pero solo se registraron las modificaciones hechas a las columnas ficticias (TRUE/FALSE , 0/1 i.e. dummy variables).\n\nmy_filled_log %&gt;% \n  filter(question == \"primary_livelihood.employment\", \n         change_type == \"change_response\") %&gt;% \n  select(uuid, question, old_value, new_value)\n\n\n\n\n\n\n\n\n\n\nuuid\nquestion\nold_value\nnew_value\n\n\n\neb3b9935-fa0b-4d54-8058-3b629f1421ad\nprimary_livelihood.employment\nTRUE\nFALSE\n\n\neec1f630-15d5-475e-a344-32bba74b32ea\nprimary_livelihood.employment\nTRUE\nFALSE\n\n\nf1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\nprimary_livelihood.employment\nTRUE\nFALSE\n\n\n\n\n\n\nLa columna principal no fue modificada y por lo tanto, acorde al ejemplo anterior, ‘employment’ sigue marcado en la columna principal.\n\nmy_clean_data %&gt;% \n  filter(X_uuid %in% c(\"eb3b9935-fa0b-4d54-8058-3b629f1421ad\", \"eec1f630-15d5-475e-a344-32bba74b32ea\", \"f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\")) %&gt;% \n  select(X_uuid,primary_livelihood, primary_livelihood.employment)\n\n\n\n\n\n\n\n\n\nX_uuid\nprimary_livelihood\nprimary_livelihood.employment\n\n\n\nf1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\nemployment\nFALSE\n\n\neb3b9935-fa0b-4d54-8058-3b629f1421ad\nemployment ngo\nFALSE\n\n\neec1f630-15d5-475e-a344-32bba74b32ea\nemployment\nFALSE\n\n\n\n\n\n\nLa función recreate_parent_column modifica la columna principal basandosé en las columnas ficticias.\n\nmy_clean_data2 &lt;- recreate_parent_column(dataset = my_clean_data,\n                                         uuid_column = \"X_uuid\",\n                                         kobo_survey = my_kobo_survey,\n                                         kobo_choices = my_kobo_choice,\n                                         sm_separator = \".\", \n                                         cleaning_log_to_append = my_filled_log)\n\nComo se puede ver, la columna principal esta correcta y ‘employment’ ya no aparece como respuesta.\n\nmy_clean_data2$data_with_fix_concat %&gt;% \n  filter(X_uuid %in% c(\"eb3b9935-fa0b-4d54-8058-3b629f1421ad\", \"eec1f630-15d5-475e-a344-32bba74b32ea\", \"f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\")) %&gt;% \n  select(X_uuid,primary_livelihood, primary_livelihood.employment)\n\n\n\n\n\n\n\n\n\nX_uuid\nprimary_livelihood\nprimary_livelihood.employment\n\n\n\nf1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\nNA\nFALSE\n\n\neb3b9935-fa0b-4d54-8058-3b629f1421ad\nngo\nFALSE\n\n\neec1f630-15d5-475e-a344-32bba74b32ea\nNA\nFALSE\n\n\n\n\n\n\nAl haber especificado el parametro cleaning_log_to_append, los cambios hechos fueron añadidos al registro de limpieza.\n\nmy_clean_data2$cleaning_log %&gt;% \n  filter(question == \"primary_livelihood\", \n         uuid %in% c(\"eb3b9935-fa0b-4d54-8058-3b629f1421ad\", \"eec1f630-15d5-475e-a344-32bba74b32ea\", \"f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\")) %&gt;% \n  select(uuid, question, old_value, new_value)\n\n\n\n\n\n\n\n\n\n\nuuid\nquestion\nold_value\nnew_value\n\n\n\neb3b9935-fa0b-4d54-8058-3b629f1421ad\nprimary_livelihood\nemployment ngo\nngo\n\n\neec1f630-15d5-475e-a344-32bba74b32ea\nprimary_livelihood\nemployment\nNA\n\n\nf1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\nprimary_livelihood\nemployment\nNA",
    "crumbs": [
      "Cleaning session 2",
      "02 - Crear un conjunto de datos limpios"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-02-create-clean-dataset.html#review_others",
    "href": "02-cleaning/02-cleaning-02-create-clean-dataset.html#review_others",
    "title": "02 - Crear un conjunto de datos limpios",
    "section": "review_others",
    "text": "review_others\nEn el registro de limpieza, algunos valores de texto abierto se cambian a vacío. Algunas preguntas de texto abierto están vinculadas a una lógica condicional, es decir, ¿qué es X? Otro, por favor especifique. En algunos casos, algunos valores deben ser cambiados. En el siguiente ejemplo, se cambio el valor de water_supply_other_neighbourhoods_why* de la encuesta uuid 019bc718-c06a-46b8-bba8-c84f6c6efbd5.\n\nmy_filled_log %&gt;% \n  filter(question == \"water_supply_other_neighbourhoods_why\", \n         change_type == \"blank_response\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuuid\nold_value\nquestion\nissue\ncheck_id\ncheck_binding\nchange_type\nnew_value\nenumerator_num\n\n\n019bc718-c06a-46b8-bba8-c84f6c6efbd5\nلا اعلم\nwater_supply_other_neighbourhoods_why\nrecode other\nNA\nwater_supply_other_neighbourhoods_why / 019bc718-c06a-46b8-bba8-c84f6c6efbd5\nblank_response\nNA\n12\n\n\n\n\n\nEn la herramienta KOBO se puede notar una logical condicional basada en la variable water_supply_other_neighbourhoods.\n\nmy_kobo_survey %&gt;% \n  filter(name == \"water_supply_other_neighbourhoods_why\") %&gt;% \n  select(type, name, relevant)\n\n\n\n\n\n\n\n\n\ntype\nname\nrelevant\n\n\ntext\nwater_supply_other_neighbourhoods_why\nselected(\\({water_supply_other_neighbourhoods},'somewhat_worse') or selected(\\){water_supply_other_neighbourhoods},‘much_worse’)\n\n\n\n\n\n\nmy_clean_data %&gt;% \n  filter(X_uuid == \"019bc718-c06a-46b8-bba8-c84f6c6efbd5\") %&gt;% \n  select(water_supply_other_neighbourhoods, water_supply_other_neighbourhoods_why   )\n\n\n\n\n\n\n\n\nwater_supply_other_neighbourhoods\nwater_supply_other_neighbourhoods_why\n\n\nsomewhat_worse\nNA\n\n\n\n\n\n¿Debe cambiarse el valor de water_supply_other_neighbourhoods? Depende de la pregunta y de la lógica condicional, pero es importante señalarlos para que se pueda tomar una decisión.\n\nreview_other_log &lt;- review_others(dataset = my_clean_data2$data_with_fix_concat,\n                                  uuid_column = \"X_uuid\", \n                                  kobo_survey = my_kobo_survey, \n                                  columns_not_to_check = \"consent_telephone_number\")\n\nWarning in create_logic_for_other(kobo_survey = kobo_survey,\ncompare_with_dataset = TRUE, : The following parent names: well_quality,\nspring_quality, rainwater_quality, surface_quality, why_not_connected were not\nfound in the dataset. The function is ignoring them.",
    "crumbs": [
      "Cleaning session 2",
      "02 - Crear un conjunto de datos limpios"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-04-exercise.html",
    "href": "01-cleaning/01-cleaning-04-exercise.html",
    "title": "04 - Ejercicios - session 1",
    "section": "",
    "text": "Probar lo siguiente con un conjunto de datos:\n\nRealiza una verificación para detectar información de identificación personal.\n\n\nlibrary(cleaningtools)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\nPruebe con la función check_pii\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nmy_raw_dataset %&gt;% \n  check_pii(uuid_column = \"X_uuid\")\n\n\n\n\n\n\nRealize una verificación que examine los porcentajes de valores faltantes por encuesta y que señale cualquier observación atípica.\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\nPruebe con la función check_percentage_missing\n\n\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento añadir una nueva columna con add_percentage_missing ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nmy_data_with_missing &lt;- my_raw_dataset %&gt;% \n  add_percentage_missing(kobo_survey = my_kobo_survey)\n  \nmy_data_with_missing %&gt;% \n  check_percentage_missing(uuid_column = \"X_uuid\")\n\nSi ya estás utilizando un registro\n\n\n\n\n\nComplete una tabla Excel para realizar las siguientes verificaciones lógicas :\n\nEl número de miembros del hogar (variable: num_hh_member) es superior a 8.\nLa fuente de agua para beber es agua embotellada (variable: water_source_drinking, value: bottled) y el hogar siempre trata el agua (variable: treat_drink_water, value: always_treat).\nLa fuente de agua para beber es agua embotellada (variable: water_source_drinking, value: bottled) y una de las principales razones por las que el hogar no satisface sus nececidades de agua es la presión del agua (variable: access_water_enough_why_not, value: water_pressure, this is a select multiple)\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\nlabel::English (en)\ntype\n\n\n\nnum_hh_member\nHow many members are there in your household (including you)?\ninteger\n\n\nwater_source_drinking\nWhat is the main source of water used by your household for drinking?\nselect_one water_sources\n\n\ntreat_drink_water\nDoes your household treat this water in any way to make it safer to drink?\nselect_one treat\n\n\naccess_water_enough_why_not\nWhat are the main reasons your household is not able to meet its water needs?\nselect_multiple barriers_water_needs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\nlabel::English (en)\nlist_name\n\n\n\nbottled\nBottled or sachet water\nwater_sources\n\n\nalways_treat\nYes, always treat it before drinking\ntreat\n\n\nwater_pressure\nWater pressure is not high enough/pumps required\nbarriers_water_needs\n\n\n\n\n\n\n\nexercise_check_list &lt;- readxl::read_excel(\"../inputs/01 - example - check_list.xlsx\")\n\nmy_raw_dataset %&gt;% \n    check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = exercise_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nmy_check_list &lt;- data.frame(check_id = c(\"check_household number\", \"check_water_treatment\", \"check_3\"),\n                            description = c(\"num_hh_member is big\",\"using bottled water and always treat\",\"using bottled water and main reason is water pressure\"),\n                            check_to_perform = c(\"num_hh_member &gt; 8\",\"water_source_drinking == \\\"bottled\\\" & treat_drink_water == \\\"always_treat\\\"\",\"water_source_drinking == \\\"bottled\\\" & access_water_enough_why_not.water_pressure == TRUE\"),\n                            columns_to_clean = c(\"num_hh_member\",\"water_source_drinking, treat_drink_water\",\"water_source_drinking, access_water_enough_why_not.water_pressure\"))\n\nmy_raw_dataset %&gt;% \n    check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = my_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n\n\n\n\n\n\nIntente añadir la duración con los archivos de auditoría (es decir, los audit files de la herramienta KOBO).\n\n\n\n\n\n\n\nHaga clic para ver una clave.\n\n\n\n\n\nPruebe usando las funciones create_audit_list() y add_duration_from_audit()",
    "crumbs": [
      "Cleaning session 1",
      "04 - Ejercicios - session 1"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-1",
    "href": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-1",
    "title": "04 - Ejercicios - session 1",
    "section": "",
    "text": "Probar lo siguiente con un conjunto de datos:\n\nRealiza una verificación para detectar información de identificación personal.\n\n\nlibrary(cleaningtools)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\nPruebe con la función check_pii\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nmy_raw_dataset %&gt;% \n  check_pii(uuid_column = \"X_uuid\")",
    "crumbs": [
      "Cleaning session 1",
      "04 - Ejercicios - session 1"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-2",
    "href": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-2",
    "title": "04 - Ejercicios - session 1",
    "section": "",
    "text": "Realize una verificación que examine los porcentajes de valores faltantes por encuesta y que señale cualquier observación atípica.\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\nPruebe con la función check_percentage_missing\n\n\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento añadir una nueva columna con add_percentage_missing ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nmy_data_with_missing &lt;- my_raw_dataset %&gt;% \n  add_percentage_missing(kobo_survey = my_kobo_survey)\n  \nmy_data_with_missing %&gt;% \n  check_percentage_missing(uuid_column = \"X_uuid\")\n\nSi ya estás utilizando un registro",
    "crumbs": [
      "Cleaning session 1",
      "04 - Ejercicios - session 1"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-3",
    "href": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-3",
    "title": "04 - Ejercicios - session 1",
    "section": "",
    "text": "Complete una tabla Excel para realizar las siguientes verificaciones lógicas :\n\nEl número de miembros del hogar (variable: num_hh_member) es superior a 8.\nLa fuente de agua para beber es agua embotellada (variable: water_source_drinking, value: bottled) y el hogar siempre trata el agua (variable: treat_drink_water, value: always_treat).\nLa fuente de agua para beber es agua embotellada (variable: water_source_drinking, value: bottled) y una de las principales razones por las que el hogar no satisface sus nececidades de agua es la presión del agua (variable: access_water_enough_why_not, value: water_pressure, this is a select multiple)\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\nlabel::English (en)\ntype\n\n\n\nnum_hh_member\nHow many members are there in your household (including you)?\ninteger\n\n\nwater_source_drinking\nWhat is the main source of water used by your household for drinking?\nselect_one water_sources\n\n\ntreat_drink_water\nDoes your household treat this water in any way to make it safer to drink?\nselect_one treat\n\n\naccess_water_enough_why_not\nWhat are the main reasons your household is not able to meet its water needs?\nselect_multiple barriers_water_needs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\nlabel::English (en)\nlist_name\n\n\n\nbottled\nBottled or sachet water\nwater_sources\n\n\nalways_treat\nYes, always treat it before drinking\ntreat\n\n\nwater_pressure\nWater pressure is not high enough/pumps required\nbarriers_water_needs\n\n\n\n\n\n\n\nexercise_check_list &lt;- readxl::read_excel(\"../inputs/01 - example - check_list.xlsx\")\n\nmy_raw_dataset %&gt;% \n    check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = exercise_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nmy_check_list &lt;- data.frame(check_id = c(\"check_household number\", \"check_water_treatment\", \"check_3\"),\n                            description = c(\"num_hh_member is big\",\"using bottled water and always treat\",\"using bottled water and main reason is water pressure\"),\n                            check_to_perform = c(\"num_hh_member &gt; 8\",\"water_source_drinking == \\\"bottled\\\" & treat_drink_water == \\\"always_treat\\\"\",\"water_source_drinking == \\\"bottled\\\" & access_water_enough_why_not.water_pressure == TRUE\"),\n                            columns_to_clean = c(\"num_hh_member\",\"water_source_drinking, treat_drink_water\",\"water_source_drinking, access_water_enough_why_not.water_pressure\"))\n\nmy_raw_dataset %&gt;% \n    check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = my_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")",
    "crumbs": [
      "Cleaning session 1",
      "04 - Ejercicios - session 1"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-adicional",
    "href": "01-cleaning/01-cleaning-04-exercise.html#ejercicio-adicional",
    "title": "04 - Ejercicios - session 1",
    "section": "",
    "text": "Intente añadir la duración con los archivos de auditoría (es decir, los audit files de la herramienta KOBO).\n\n\n\n\n\n\n\nHaga clic para ver una clave.\n\n\n\n\n\nPruebe usando las funciones create_audit_list() y add_duration_from_audit()",
    "crumbs": [
      "Cleaning session 1",
      "04 - Ejercicios - session 1"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-01-create-cleaning-log.html",
    "href": "02-cleaning/02-cleaning-01-create-cleaning-log.html",
    "title": "01 - Creando un registro de limpieza",
    "section": "",
    "text": "library(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\nEn esta sección continuamos con el paso de limpieza.",
    "crumbs": [
      "Cleaning session 2",
      "01 - Creando un registro de limpieza"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-01-create-cleaning-log.html#create_combined_log",
    "href": "02-cleaning/02-cleaning-01-create-cleaning-log.html#create_combined_log",
    "title": "01 - Creando un registro de limpieza",
    "section": "create_combined_log",
    "text": "create_combined_log\nLa función create_combined_log combina todos los registros de una lista en uno. La función añade también dos columnas necesarias durante el proceso de limpieza.\n\nnames(more_logs)\n\n[1] \"checked_dataset\"    \"duplicate_log\"      \"soft_duplicate_log\"\n[4] \"potential_outliers\" \"flaged_value\"       \"duration_log\"      \n[7] \"other_log\"          \"logical_all\"       \n\nmy_combined_log &lt;- create_combined_log(more_logs)\n\nList of element to combine- checked_dataset, duplicate_log, soft_duplicate_log, potential_outliers, flaged_value, duration_log, other_log, logical_all\n\ntypeof(my_combined_log)\n\n[1] \"list\"\n\nnames(my_combined_log)\n\n[1] \"checked_dataset\" \"cleaning_log\"   \n\nmy_combined_log$cleaning_log %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuuid\nold_value\nquestion\nissue\ncheck_id\ncheck_binding\nchange_type\nnew_value\n\n\n\nb5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06\n86\nage_respondent_r\noutlier (normal distribution)\nNA\nage_respondent_r / b5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06\nNA\nNA\n\n\n956b5ed0-5a62-41b7-aec3-af93fbc5b494\n84\nage_respondent_r\noutlier (normal distribution)\nNA\nage_respondent_r / 956b5ed0-5a62-41b7-aec3-af93fbc5b494\nNA\nNA\n\n\n97ad6294-30c6-454e-a0b3-42126415b767\n18\nage_respondent_r\noutlier (log distribution)\nNA\nage_respondent_r / 97ad6294-30c6-454e-a0b3-42126415b767\nNA\nNA\n\n\ne005e719-57c4-44a3-ac2f-5d6d1ff68831\n18\nage_respondent_r\noutlier (log distribution)\nNA\nage_respondent_r / e005e719-57c4-44a3-ac2f-5d6d1ff68831\nNA\nNA\n\n\nc9aaa542-118f-4e42-93de-fb0916572541\n19\nnum_hh_member\noutlier (normal distribution)\nNA\nnum_hh_member / c9aaa542-118f-4e42-93de-fb0916572541\nNA\nNA\n\n\n48e8896b-d1be-4600-8839-2d8b994ebcfb\n19\nnum_hh_member\noutlier (normal distribution)\nNA\nnum_hh_member / 48e8896b-d1be-4600-8839-2d8b994ebcfb\nNA\nNA\n\n\n\n\n\n\nEl registro de limpieza contiene todas las columnas de todos los registros en more_logs y ademas contiene las siguientes columnas:\n\ncheck_binding : esta columna se rellena automáticamente.\nchange_type (vacía)\nnew_value (vacía)",
    "crumbs": [
      "Cleaning session 2",
      "01 - Creando un registro de limpieza"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-01-create-cleaning-log.html#add_info_to_cleaning_log",
    "href": "02-cleaning/02-cleaning-01-create-cleaning-log.html#add_info_to_cleaning_log",
    "title": "01 - Creando un registro de limpieza",
    "section": "add_info_to_cleaning_log",
    "text": "add_info_to_cleaning_log\nSi se desea añadir mas información al registro de limpieza, se puede usar la función add_info_to_cleaning_log.\n\n\n\n\n\n\nadd_*\n\n\n\n\nLas funciones add_* añaden una variable (columna) al conjunto de datos. Por ejemplo, se puede añadir la duración de la encuesta o la categoría de puntaje de consumo de alimentos (FCS)…\nUna función add_* toma a un conjunto de datos como entrada y retorna el conjunto de datos incluyendo el nuevo indicador (tambien añadira todos las columnas necesarias para el calculo del nuevo indicador).\nPor ejemplo, para comprobar la duración de una encuesta teniendo las variables de inicio y fin de la encuesta.\n\n\n\nmy_combined_log &lt;- my_combined_log %&gt;% \n  add_info_to_cleaning_log(dataset_uuid_column = \"X_uuid\", \n                           information_to_add = \"enumerator_num\")\n\nmy_combined_log$cleaning_log %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuuid\nold_value\nquestion\nissue\ncheck_id\ncheck_binding\nchange_type\nnew_value\nenumerator_num\n\n\n\n019bc718-c06a-46b8-bba8-c84f6c6efbd5\nلا اعلم\nwater_supply_other_neighbourhoods_why\nrecode other\nNA\nwater_supply_other_neighbourhoods_why / 019bc718-c06a-46b8-bba8-c84f6c6efbd5\nNA\nNA\n12\n\n\n019bc718-c06a-46b8-bba8-c84f6c6efbd5\nلا ارى جدوى من ذلك\nprefer_not_engage_other\nrecode other\nNA\nprefer_not_engage_other / 019bc718-c06a-46b8-bba8-c84f6c6efbd5\nNA\nNA\n12\n\n\n019bc718-c06a-46b8-bba8-c84f6c6efbd5\nالسلطات ليست مهتمة بالخدمات\ntrust_water_office_why_not\nrecode other\nNA\ntrust_water_office_why_not / 019bc718-c06a-46b8-bba8-c84f6c6efbd5\nNA\nNA\n12\n\n\n019bc718-c06a-46b8-bba8-c84f6c6efbd5\n247.20\nduration\nDuration is lower or higher than the thresholds\nNA\nduration / 019bc718-c06a-46b8-bba8-c84f6c6efbd5\nNA\nNA\n12\n\n\n03183d24-0275-43fe-8976-d076f29de590\nعدم توفير خدمه المياه في المنطقه وضعف في تزويد خدمه وعدد ساعات اقل تجهيز للبيوت\nwater_supply_other_neighbourhoods_why\nrecode other\nNA\nwater_supply_other_neighbourhoods_why / 03183d24-0275-43fe-8976-d076f29de590\nNA\nNA\n2\n\n\n03183d24-0275-43fe-8976-d076f29de590\n10\npay_water_charges_amount\noutlier (log distribution)\nNA\npay_water_charges_amount / 03183d24-0275-43fe-8976-d076f29de590\nNA\nNA\n2",
    "crumbs": [
      "Cleaning session 2",
      "01 - Creando un registro de limpieza"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-01-create-cleaning-log.html#create_xlsx_cleaning_log",
    "href": "02-cleaning/02-cleaning-01-create-cleaning-log.html#create_xlsx_cleaning_log",
    "title": "01 - Creando un registro de limpieza",
    "section": "create_xlsx_cleaning_log",
    "text": "create_xlsx_cleaning_log\n\ncreate_xlsx_cleaning_log(my_combined_log,\n                         sm_dropdown_type = \"logical\",\n                         output_path =  \"../outputs/01 - example - cleaning-log-no-kobo.xlsx\")\n\nLa función create_xlsx_cleaning_log crea una tabla Excel que contiene:\n\nchecked_dataset: la pestaña con el conjunto de datos verificado y las columnas añadidas si hay.\ncleaning_log: la pestaña con los registros combinados y la columna change_type que describe las posibles modificaciones.\nreadme tab: la pestaña con la definición de las opciones para la columna change_type (en inglés).\n\nHay 4 acciones posibles:\n\nchange_response: cambiar al valor especificado en la columna new.value,\nblank_response: remplazar el valor por NA,\nremove_survey: borrar la encuesta,\nno_action: no hacer nada.\n\nEn el registro se debe indicar la acción por hacer y, si necesario, el nuevo valor.\n\ncreate_xlsx_cleaning_log(my_combined_log,\n                         kobo_survey = my_kobo_survey,\n                         kobo_choices = my_kobo_choice,\n                         use_dropdown = T,\n                         sm_dropdown_type = \"logical\",\n                         output_path =  \"../outputs/02 - example - cleaning-log-with-kobo.xlsx\")\n\nEn las entradas de la función, se puede especificar la herramienta KOBO. Si se específica la herramienta y que el argumento use_dropdown está configurado como TRUE, new_value tendrá una regla de validación de datos basada en las opciones de la herramienta KOBO.\n\n\n\n\n\n\nNota\n\n\n\nEn el caso de variables de opción multiple, se señalan las columnas ficticias (TRUE/FALSE o 0/1 i.e. dummy columns) y son esas las columnas usadas durante el proceso de limpieza, no la columna principal.",
    "crumbs": [
      "Cleaning session 2",
      "01 - Creando un registro de limpieza"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-03-logical-with-lists.html",
    "href": "01-cleaning/01-cleaning-03-logical-with-lists.html",
    "title": "03 - verificación con lista de lógicas",
    "section": "",
    "text": "library(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices",
    "crumbs": [
      "Cleaning session 1",
      "03 - verificación con lista de lógicas"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-03-logical-with-lists.html#check_logical_with_list",
    "href": "01-cleaning/01-cleaning-03-logical-with-lists.html#check_logical_with_list",
    "title": "03 - verificación con lista de lógicas",
    "section": "check_logical_with_list",
    "text": "check_logical_with_list\nEn otros casos, la verificación es específica y debe ser adaptada al conjunto de datos. Es el caso de la función check_logical_with_list, a la cual se le puede dar como entrada una tabla de Excel con las verificaciones lógicas por aplicar.\n\nlogical_check_list &lt;- readxl::read_excel(\"../inputs/01 - example - check_list.xlsx\")\nlogical_check_list\n\n\n\n\n\n\n\n\n\n\ncheck_id\ndescription\ncheck_to_perform\ncolumns_to_clean\n\n\n\ncheck_1\nprimary_livelihood is employment but expenses less than 200000\nprimary_livelihood.employment == 1 & tot_expenses &lt; 200000\nprimary_livelihood.employment,\n\n\ntot_expenses\n\n\n\n\n\ncheck_2\nacces water and tank emptied\naccess_water_enough == “totally_insufficient” & tank_emptied == “about_half”\naccess_water_enough, tank_emptied\n\n\n\n\n\n\nLa entrada, es decir, la tabla de Excel con las verificaciones lógicas, debe tener 4 columnas:\n\ncheck_id : el nombre de la verificación\ndescription : la descripcion de la verificacion\ncheck_to_perform : la verificación por hacer. El formato de la verificación por hacer debe ser compatible con tidyverse. Se debe usar un formato similar al que se utilizaría en la función mutate para crear un nuevo indicador lógico (es decir, TRUE o FALSE). La verificación lógica debe estar escrita de manera que la salida TRUE corresponda a la encuesta que se quiera señalar.\ncolumns_to_clean : la lista de columnas utilizadas para la verificación lógica.\n\nUna tal lista se puede utilizar con check_logical_with_list.\n\nexample_logic &lt;- my_raw_dataset %&gt;% \n  check_logical_with_list(uuid_column = \"X_uuid\",\n                          list_of_check = logical_check_list,\n                          check_id_column = \"check_id\",\n                          check_to_perform_column = \"check_to_perform\",\n                          columns_to_clean_column = \"columns_to_clean\",\n                          description_column = \"description\")\n\n\nexample_logic$logical_all %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\n\n\nuuid\nquestion\nold_value\nissue\ncheck_id\ncheck_binding\n\n\n\nf1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\nprimary_livelihood.employment\nTRUE\nprimary_livelihood is employment but expenses less than 200000\ncheck_1\ncheck_1 / f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\n\n\nf1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\ntot_expenses\n125000\nprimary_livelihood is employment but expenses less than 200000\ncheck_1\ncheck_1 / f1175d29-ce1f-43a7-b3d1-ee26cd1b8cdb\n\n\ne9f8b44c-c507-45a1-8d76-66d886437b8f\nprimary_livelihood.employment\nTRUE\nprimary_livelihood is employment but expenses less than 200000\ncheck_1\ncheck_1 / e9f8b44c-c507-45a1-8d76-66d886437b8f\n\n\ne9f8b44c-c507-45a1-8d76-66d886437b8f\ntot_expenses\n175000\nprimary_livelihood is employment but expenses less than 200000\ncheck_1\ncheck_1 / e9f8b44c-c507-45a1-8d76-66d886437b8f\n\n\n994a60b8-e640-425c-9774-160651d7af04\nprimary_livelihood.employment\nTRUE\nprimary_livelihood is employment but expenses less than 200000\ncheck_1\ncheck_1 / 994a60b8-e640-425c-9774-160651d7af04\n\n\n994a60b8-e640-425c-9774-160651d7af04\ntot_expenses\n175000\nprimary_livelihood is employment but expenses less than 200000\ncheck_1\ncheck_1 / 994a60b8-e640-425c-9774-160651d7af04\n\n\n\n\n\n\nEl registro que se obtiene contiene las siguientes columnas:\n\nuuid: el identificador único de la encuesta\nquestion: el nombre de la columna señalada, sera un elemento de la lista columns_to_clean\n\nold value: el valor en la columna de columns_to_clean señalada\nissue: el problema señalado\ncheck_id: el identificador de la verificación lógica\ncheck_binding: una combinación del check_id y del uuid.\n\nPara una verificación dada, el registro tendrá varias líneas relativas al mismo señalamiento. En el ejemplo anterior, para cada uuid, los valores de las columnas primary_livelihood y tot_expenses son señalados (una línea por cada uuid por cada columna en columns_to_clean).\nEl formato de la verificación por hacer debe ser compatible con tidyverse. Se debe usar un formato similar al que se utilizaría en la función mutate para crear un nuevo indicador lógico (es decir, TRUE o FALSE). La verificación lógica debe estar escrita de manera que la salida TRUE corresponda a la encuesta que se quiera señalar.\n\nmy_raw_dataset %&gt;% \n  dplyr::mutate(xxx =  primary_livelihood.employment == 1 & tot_expenses &lt; 200000) %&gt;% \n  dplyr::select(X_uuid, xxx, primary_livelihood.employment, tot_expenses) %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\nX_uuid\nxxx\nprimary_livelihood.employment\ntot_expenses\n\n\n\ndcf2753a-6ea2-40f5-b493-3527931ef96c\nFALSE\nFALSE\n250000\n\n\n8790ce5c-1c35-41a2-b3c0-538f937d5397\nFALSE\nTRUE\n750000\n\n\nbb818e04-9c40-408e-919f-6b40ff1fdbb3\nFALSE\nFALSE\n250000\n\n\n28b90cbb-2cf0-41c5-9ee1-1c719c0d4c02\nFALSE\nTRUE\n600000\n\n\n7f2a0c6a-529b-481f-963f-a96dca2ec034\nFALSE\nTRUE\n500000\n\n\nb4f92064-12ea-4970-b0f5-fd309de1dda3\nFALSE\nFALSE\n650000\n\n\n\n\n\n\nEl conjunto de datos verificado incluirá columnas adicionales. Estas columnas tendrán el nombre del check_id y contendrán valores lógicos.\n\nexample_logic$checked_dataset[1:6,tail(names(example_logic$checked_dataset))]\n\n\n\n\nX_notes\nX_status\nX_submitted_by\nX_index\ncheck_1\ncheck_2\n\n\n\n[]\nsubmitted_via_web\nreach_irq\n1\nFALSE\nFALSE\n\n\n[]\nsubmitted_via_web\nreach_irq\n2\nFALSE\nFALSE\n\n\n[]\nsubmitted_via_web\nreach_irq\n3\nFALSE\nFALSE\n\n\n[]\nsubmitted_via_web\nreach_irq\n4\nFALSE\nFALSE\n\n\n[]\nsubmitted_via_web\nreach_irq\n5\nFALSE\nFALSE\n\n\n[]\nsubmitted_via_web\nreach_irq\n6\nFALSE\nFALSE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nSi no se incluya la lista columns_to_clean la funcion check_logical_with_list intentará identificar las variables de forma automática. Sin embargo, no se puede garantizar que seleccione los nombres correctos.",
    "crumbs": [
      "Cleaning session 1",
      "03 - verificación con lista de lógicas"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-05-extra.html",
    "href": "02-cleaning/02-cleaning-05-extra.html",
    "title": "05 - Plantillas de revisión",
    "section": "",
    "text": "Plantillas de revisión\nHay algunas plantillas de proyecto que se pueden utilizar para revisar la limpieza. Más información en este repositorio Github..",
    "crumbs": [
      "Cleaning session 2",
      "05 - Plantillas de revisión"
    ]
  },
  {
    "objectID": "00-intro.html",
    "href": "00-intro.html",
    "title": "01 - El marco R con IMPACT Initiatives",
    "section": "",
    "text": "IMPACT R framework\n\nEl marco R de IMPACT se desarrollo para cumplir con los requisitos del ciclo de investigación IMPACT.  El marco es modular y tiene dos dimensiones:\n\nuna dimensión horizontal que se centra en el resultado de un cierto paso, y\nuna dimensión vertical que se centra en el contenido de un cierto paso.\n\nEl marco se basa en :\n\n4 etapas:\n\nLimpieza: cualquier manipulación necesaria para pasar de los datos brutos a los datos limpios.\nComposición: cualquier manipulaciòn anterior al análisis p.ej., añadir indicadores, añadir información proveniente del bucle o del dato principal , agragación por AOK, etc.\nAnálisis: cualquier manipulaciòn que sea relativa al análisis unicamente\nResultados: cualquier manipulaciòn necesaria para formatear los resultados.\n\n4 verbos:\n\nAdd: (añadir) funciones que añaden una nueva variable (columna) a los datos.\nCheck: (verificar) funciones que maracarán valores basándose en una verificación específica. Retornarán estos valores en un registro. Una función check_* devolverá una lista: el conjunto de datos verificado y el registro. La función toma un conjunto de datos como entrada y devuelve el conjunto de datos + el nuevo indicador (y cualquier paso intermedio utilizado para el cálculo).\nCreate: (crear) funciones que crearán o transformaran algun objecto p.ej. functiones que crearán o transformarán algun objeto creando un registro de limpieza con las verificaciones por hacer, creando una tabla de resultados del análisis etc. Las salidas de las funciones create_* pueden tener formatos diversos.\nReview: (revisar) funciones que revisarán un objeto comparándolo con estándares u otro objeto y señalaran las diferencias. Por ejemplo, revisando la limpieza comparando el conjunto de datos original, el conjunto de datos limpio y el registro de limplieza o comparando los resultados de dos análisis.\n\n** 2 adjetivos**:\n\nPipe-able: (encadenable) En el marco, las funciones de la misma familia son encadenables (es decir, se pueden aplicar una después de la otra). En el siguiento ejemplo, se encadenan dos funciones check_*.\nIndependiente: En cualquier paso dado, el usuario puede cambiar de herramienta. Cada entrada y cada salida de un paso deben seguir el mismo formato y definición.\n\n\nEl objetivo es que este conjunto de elementos ayude a la cooperación y colaboración entre diferentes equipos. Las herramientas presentes en este marco deben ser adaptables a cada contexto y evaluación.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-02-add-duration-others.html",
    "href": "01-cleaning/01-cleaning-02-add-duration-others.html",
    "title": "02 - Añadir, duracion y otros",
    "section": "",
    "text": "library(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\n\nmore_logs &lt;- my_raw_dataset %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\") %&gt;% \n  check_soft_duplicates(uuid_column = \"X_uuid\", kobo_survey = my_kobo_survey, sm_separator = \".\") %&gt;%\n  check_outliers(uuid_column = \"X_uuid\") %&gt;%\n  check_value(uuid_column = \"X_uuid\")",
    "crumbs": [
      "Cleaning session 1",
      "02 - Añadir, duracion y otros"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-02-add-duration-others.html#add_duration",
    "href": "01-cleaning/01-cleaning-02-add-duration-others.html#add_duration",
    "title": "02 - Añadir, duracion y otros",
    "section": "add_duration",
    "text": "add_duration\n\n\n\n\n\n\nadd_*\n\n\n\n\nLas funciones add_* añadirán una variable (columna) al conjunto de datos. Por ejemplo, añadirán la duración de una encuesta, añadiran la categoría de puntaje de consumo de alimentos, etc.\nUna funcion add_* toma un conjunto de datos como entrada y devuelve el conjunto de datos + el nuevo indicador (y cualquier paso intermedia utilizado para el cálculo).\nEn el ejemplo siguiento, se usa la funcion add_duration para añadir la duración de la encuesta usando el tiempo de inicio y de fin.\n\n\n\nmore_logs$checked_dataset &lt;- more_logs$checked_dataset %&gt;% \n  add_duration(uuid_column = \"X_uuid\", start_column = \"X.U.FEFF.start\", end_column = \"end\")\nmore_logs$checked_dataset[1:6, c(\"start_date\", \"start_time\", \"end_date\", \"end_time\", \"days_diff\", \"duration\")]\n\n\n\n\n\n\n\n\n\n\n\n\nstart_date\nstart_time\nend_date\nend_time\ndays_diff\nduration\n\n\n\n2021-07-05\n658.57 mins\n2021-07-05\n696.68 mins\n0 days\n38.11\n\n\n2021-07-05\n608.90 mins\n2021-07-05\n641.92 mins\n0 days\n33.02\n\n\n2021-07-05\n682.23 mins\n2021-07-05\n726.43 mins\n0 days\n44.20\n\n\n2021-07-04\n1342.98 mins\n2021-07-04\n1380.15 mins\n0 days\n37.17\n\n\n2021-07-04\n1391.62 mins\n2021-07-05\n18.88 mins\n1 days\n67.26\n\n\n2021-07-05\n617.38 mins\n2021-07-05\n756.52 mins\n0 days\n139.14\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nLa duración se añade a checked_dataset en la lista, no a my_raw_dataset. Las funciones check_* se utilizan en cadena, por lo cual es necesario que el conjunto actual de datos sea modificado.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn este momento, la funcion add_duration acepta solo un formato muy específico. En el futuro, cambiará para volverse màs robusta y se harà usando lubridate.\n\n\ncheck_duration se puede utilizar en cadena con las verificaciones anteriores.\n\nmore_logs &lt;- more_logs %&gt;% \n  check_duration(column_to_check = \"duration\", uuid_column = \"X_uuid\")\n\nEn la medida de lo posible, las funciones check_* toman argumentos predeterminados o infieren la información necesaria, p.ej. la funcion check_outliers infiere que columnas contienen valores numericos. Ciertas funciones requieren mãs informaciòn.",
    "crumbs": [
      "Cleaning session 1",
      "02 - Añadir, duracion y otros"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-02-add-duration-others.html#columnas-de-texto",
    "href": "01-cleaning/01-cleaning-02-add-duration-others.html#columnas-de-texto",
    "title": "02 - Añadir, duracion y otros",
    "section": "Columnas de texto",
    "text": "Columnas de texto\nLa funcion check_other necesita la lista de columnas que se deben verificar. Al momento, no es capaz de detectar preguntas de texto abierto. Se puede utilizar la herramienta KOBO.\n\nother_columns_to_check &lt;- my_kobo_survey %&gt;% \n  dplyr::filter(type == \"text\") %&gt;% \n  dplyr::filter(name %in% names(my_raw_dataset)) %&gt;%\n  dplyr::pull(name) \n\nmore_logs &lt;- more_logs %&gt;% \n  check_others(uuid_column = \"X_uuid\", columns_to_check = other_columns_to_check)",
    "crumbs": [
      "Cleaning session 1",
      "02 - Añadir, duracion y otros"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-03-review-cleaning.html",
    "href": "02-cleaning/02-cleaning-03-review-cleaning.html",
    "title": "03 - Revisar la limpieza",
    "section": "",
    "text": "library(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\nmy_filled_log &lt;- readxl::read_excel(\"../inputs/02 - example - cleaning-log-with-kobo - filled.xlsx\", sheet = 2)\n\nmy_clean_data &lt;- create_clean_data(raw_dataset = my_raw_dataset,\n                                   raw_data_uuid_column = \"X_uuid\",\n                                   cleaning_log = my_filled_log, \n                                   cleaning_log_uuid_column = \"uuid\",\n                                   cleaning_log_question_column = \"question\",\n                                   cleaning_log_new_value_column = \"new_value\",\n                                   cleaning_log_change_type_column = \"change_type\")\nmy_clean_data2 &lt;- recreate_parent_column(dataset = my_clean_data,\n                                         uuid_column = \"X_uuid\",\n                                         kobo_survey = my_kobo_survey,\n                                         kobo_choices = my_kobo_choice,\n                                         sm_separator = \".\", \n                                         cleaning_log_to_append = my_filled_log)",
    "crumbs": [
      "Cleaning session 2",
      "03 - Revisar la limpieza"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-03-review-cleaning.html#review_others",
    "href": "02-cleaning/02-cleaning-03-review-cleaning.html#review_others",
    "title": "03 - Revisar la limpieza",
    "section": "review_others",
    "text": "review_others\nEn el registro de limpieza, algunos valores de texto abierto se cambian a vacío. Algunas preguntas de texto abierto están vinculadas a una lógica condicional, es decir, ¿qué es X? Otro, por favor especifique. En algunos casos, algunos valores deben ser cambiados. En el siguiente ejemplo, se cambio el valor de water_supply_other_neighbourhoods_why* de la encuesta uuid 019bc718-c06a-46b8-bba8-c84f6c6efbd5.\n\nmy_filled_log %&gt;% \n  filter(question == \"water_supply_other_neighbourhoods_why\", \n         change_type == \"blank_response\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuuid\nold_value\nquestion\nissue\ncheck_id\ncheck_binding\nchange_type\nnew_value\nenumerator_num\n\n\n019bc718-c06a-46b8-bba8-c84f6c6efbd5\nلا اعلم\nwater_supply_other_neighbourhoods_why\nrecode other\nNA\nwater_supply_other_neighbourhoods_why / 019bc718-c06a-46b8-bba8-c84f6c6efbd5\nblank_response\nNA\n12\n\n\n\n\n\nEn la herramienta KOBO se puede notar una logical condicional basada en la variable water_supply_other_neighbourhoods.\n\nmy_kobo_survey %&gt;% \n  filter(name == \"water_supply_other_neighbourhoods_why\") %&gt;% \n  select(type, name, relevant)\n\n\n\n\n\n\n\n\n\ntype\nname\nrelevant\n\n\ntext\nwater_supply_other_neighbourhoods_why\nselected(\\({water_supply_other_neighbourhoods},'somewhat_worse') or selected(\\){water_supply_other_neighbourhoods},‘much_worse’)\n\n\n\n\n\n\nmy_clean_data %&gt;% \n  filter(X_uuid == \"019bc718-c06a-46b8-bba8-c84f6c6efbd5\") %&gt;% \n  select(water_supply_other_neighbourhoods, water_supply_other_neighbourhoods_why   )\n\n\n\n\n\n\n\n\nwater_supply_other_neighbourhoods\nwater_supply_other_neighbourhoods_why\n\n\nsomewhat_worse\nNA\n\n\n\n\n\n¿Debe cambiarse el valor de water_supply_other_neighbourhoods? Depende de la pregunta y de la lógica condicional, pero es importante señalarlos para que se pueda tomar una decisión.\n\nreview_other_log &lt;- review_others(dataset = my_clean_data2$data_with_fix_concat,\n                                  uuid_column = \"X_uuid\", \n                                  kobo_survey = my_kobo_survey, \n                                  columns_not_to_check = \"consent_telephone_number\")\n\nWarning in create_logic_for_other(kobo_survey = kobo_survey,\ncompare_with_dataset = TRUE, : The following parent names: well_quality,\nspring_quality, rainwater_quality, surface_quality, why_not_connected were not\nfound in the dataset. The function is ignoring them.",
    "crumbs": [
      "Cleaning session 2",
      "03 - Revisar la limpieza"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-03-review-cleaning.html#review_cleaning",
    "href": "02-cleaning/02-cleaning-03-review-cleaning.html#review_cleaning",
    "title": "03 - Revisar la limpieza",
    "section": "review_cleaning",
    "text": "review_cleaning\n\nmy_deletion_log &lt;- my_clean_data2$cleaning_log %&gt;% \n  filter(change_type == \"remove_survey\")\n\nmy_filled_log_no_deletion &lt;- my_clean_data2$cleaning_log %&gt;% \n  filter(change_type != \"remove_survey\") %&gt;% \n  filter(!uuid %in% my_deletion_log$uuid)\n\nreview_of_cleaning &lt;- review_cleaning(raw_dataset = my_raw_dataset,\n                    raw_dataset_uuid_column = \"X_uuid\", \n                    clean_dataset = my_clean_data2$data_with_fix_concat,\n                    clean_dataset_uuid_column = \"X_uuid\",\n                    cleaning_log = my_filled_log_no_deletion, \n                    cleaning_log_uuid_column = \"uuid\",\n                    cleaning_log_question_column = \"question\",\n                    cleaning_log_new_value_column = \"new_value\",\n                    cleaning_log_change_type_column = \"change_type\", \n                    cleaning_log_old_value_column = \"old_value\", \n                    deletion_log = my_deletion_log, \n                    deletion_log_uuid_column = \"uuid\"\n                    )\n\n\nreview_of_cleaning\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuuid\ndf.question\ndf.change_type\ndf.new_value\ncl.new_value\ndf.old_value\ncl.old_value\ncomment",
    "crumbs": [
      "Cleaning session 2",
      "03 - Revisar la limpieza"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-04-exercise.html",
    "href": "02-cleaning/02-cleaning-04-exercise.html",
    "title": "04 - Ejercicios (2)",
    "section": "",
    "text": "library(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\n\n\n\nExporte el registro de limpieza creado previamente. El registro anterior ya esta cargado.\n\n\nprevious_exercise_log &lt;- readRDS(\"../inputs/03 - exercise - previous_log.RDS\")\n\nprevious_exercise_log %&gt;% names()\n\n[1] \"checked_dataset\"        \"percentage_missing_log\" \"potential_PII\"         \n[4] \"logical_all\"           \n\n\n\n\n\n\n\n\nHaga clic para obtener una pista.\n\n\n\n\n\n¿Intento usando la funcion create_combined_log ?\n\n\n\n\n\n\n\n\n\nHaga clic para obtener una pista.\n\n\n\n\n\n¿Intento usando la funcion create_xlsx_cleaning_log ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nprevious_exercise_log %&gt;% \n  create_combined_log() %&gt;%\n  create_xlsx_cleaning_log(output_path = \"../outputs/03 - correction - cleaning_log.xlsx\", \n                           kobo_survey = my_kobo_survey,\n                           kobo_choices = my_kobo_choice,\n                           sm_dropdown_type = \"logical\",\n                           use_dropdown = TRUE)\n\n\n\n\n\n\nCree los datos limpios a partir del conjunto de datos en bruto y del registro de limpieza completado.\n\n\nexercise_filled_log &lt;- readxl::read_excel(\"../inputs/04 - exercise - cleaning_log - filled.xlsx\", sheet = \"cleaning_log\")\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento usando la funcion create_clean_data ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento usando la funcion recreate_parent_column ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nexercise_clean_dataset &lt;- create_clean_data(raw_dataset = my_raw_dataset,\n                                            raw_data_uuid_column = \"X_uuid\",\n                                            cleaning_log = exercise_filled_log, \n                                            cleaning_log_uuid_column = \"uuid\",\n                                            cleaning_log_question_column = \"question\",\n                                            cleaning_log_new_value_column = \"new_value\",\n                                            cleaning_log_change_type_column = \"change_type\")\n\n\nexercise_clean_dataset2 &lt;- recreate_parent_column(exercise_clean_dataset,\n                                                  uuid_column = \"X_uuid\", \n                                                  kobo_survey = my_kobo_survey,\n                                                  kobo_choices = my_kobo_choice,\n                                                  cleaning_log_to_append = exercise_filled_log)\n\n\n\n\n\n\nRevise la limpieza a continuación; si hay alguien más haciendo el ejercicio, puede intentar revisar la limpieza de esa persona.\n\n\nexercise3_clean_dataset &lt;- readxl::read_excel(\"../inputs/05 - exercise - clean dataset for review.xlsx\")\n\nexercise3_cleaning_log &lt;- readxl::read_excel(\"../inputs/05 - exercise - clean dataset for review.xlsx\", sheet = 2)\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento usando la funcion review_cleaning ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿ Separo el registro de limpieza ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nexercise3_deletion_log &lt;- exercise3_cleaning_log %&gt;% \n  filter(change_type == \"remove_survey\")\n\nexercise3_log_no_deletion &lt;- exercise3_cleaning_log %&gt;% \n  filter(change_type != \"remove_survey\") %&gt;% \n  filter(!uuid %in% exercise3_deletion_log$uuid)\n\nreview_of_cleaning &lt;- review_cleaning(raw_dataset = my_raw_dataset,\n                                      raw_dataset_uuid_column = \"X_uuid\", \n                                      clean_dataset = exercise3_clean_dataset,\n                                      clean_dataset_uuid_column = \"X_uuid\",\n                                      cleaning_log = exercise3_log_no_deletion, \n                                      cleaning_log_uuid_column = \"uuid\",\n                                      cleaning_log_question_column = \"question\",\n                                      cleaning_log_new_value_column = \"new_value\",\n                                      cleaning_log_change_type_column = \"change_type\", \n                                      cleaning_log_old_value_column = \"old_value\", \n                                      deletion_log = exercise3_deletion_log, \n                                      deletion_log_uuid_column = \"uuid\"\n)",
    "crumbs": [
      "Cleaning session 2",
      "04 - Ejercicios (2)"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-04-exercise.html#ejercicio-1",
    "href": "02-cleaning/02-cleaning-04-exercise.html#ejercicio-1",
    "title": "04 - Ejercicios (2)",
    "section": "",
    "text": "Exporte el registro de limpieza creado previamente. El registro anterior ya esta cargado.\n\n\nprevious_exercise_log &lt;- readRDS(\"../inputs/03 - exercise - previous_log.RDS\")\n\nprevious_exercise_log %&gt;% names()\n\n[1] \"checked_dataset\"        \"percentage_missing_log\" \"potential_PII\"         \n[4] \"logical_all\"           \n\n\n\n\n\n\n\n\nHaga clic para obtener una pista.\n\n\n\n\n\n¿Intento usando la funcion create_combined_log ?\n\n\n\n\n\n\n\n\n\nHaga clic para obtener una pista.\n\n\n\n\n\n¿Intento usando la funcion create_xlsx_cleaning_log ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nprevious_exercise_log %&gt;% \n  create_combined_log() %&gt;%\n  create_xlsx_cleaning_log(output_path = \"../outputs/03 - correction - cleaning_log.xlsx\", \n                           kobo_survey = my_kobo_survey,\n                           kobo_choices = my_kobo_choice,\n                           sm_dropdown_type = \"logical\",\n                           use_dropdown = TRUE)",
    "crumbs": [
      "Cleaning session 2",
      "04 - Ejercicios (2)"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-04-exercise.html#ejercicio-2",
    "href": "02-cleaning/02-cleaning-04-exercise.html#ejercicio-2",
    "title": "04 - Ejercicios (2)",
    "section": "",
    "text": "Cree los datos limpios a partir del conjunto de datos en bruto y del registro de limpieza completado.\n\n\nexercise_filled_log &lt;- readxl::read_excel(\"../inputs/04 - exercise - cleaning_log - filled.xlsx\", sheet = \"cleaning_log\")\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento usando la funcion create_clean_data ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento usando la funcion recreate_parent_column ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nexercise_clean_dataset &lt;- create_clean_data(raw_dataset = my_raw_dataset,\n                                            raw_data_uuid_column = \"X_uuid\",\n                                            cleaning_log = exercise_filled_log, \n                                            cleaning_log_uuid_column = \"uuid\",\n                                            cleaning_log_question_column = \"question\",\n                                            cleaning_log_new_value_column = \"new_value\",\n                                            cleaning_log_change_type_column = \"change_type\")\n\n\nexercise_clean_dataset2 &lt;- recreate_parent_column(exercise_clean_dataset,\n                                                  uuid_column = \"X_uuid\", \n                                                  kobo_survey = my_kobo_survey,\n                                                  kobo_choices = my_kobo_choice,\n                                                  cleaning_log_to_append = exercise_filled_log)",
    "crumbs": [
      "Cleaning session 2",
      "04 - Ejercicios (2)"
    ]
  },
  {
    "objectID": "02-cleaning/02-cleaning-04-exercise.html#ejercicio-3",
    "href": "02-cleaning/02-cleaning-04-exercise.html#ejercicio-3",
    "title": "04 - Ejercicios (2)",
    "section": "",
    "text": "Revise la limpieza a continuación; si hay alguien más haciendo el ejercicio, puede intentar revisar la limpieza de esa persona.\n\n\nexercise3_clean_dataset &lt;- readxl::read_excel(\"../inputs/05 - exercise - clean dataset for review.xlsx\")\n\nexercise3_cleaning_log &lt;- readxl::read_excel(\"../inputs/05 - exercise - clean dataset for review.xlsx\", sheet = 2)\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿Intento usando la funcion review_cleaning ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver una pista.\n\n\n\n\n\n¿ Separo el registro de limpieza ?\n\n\n\n\n\n\n\n\n\nHaga clic para ver la respuesta.\n\n\n\n\n\n\nexercise3_deletion_log &lt;- exercise3_cleaning_log %&gt;% \n  filter(change_type == \"remove_survey\")\n\nexercise3_log_no_deletion &lt;- exercise3_cleaning_log %&gt;% \n  filter(change_type != \"remove_survey\") %&gt;% \n  filter(!uuid %in% exercise3_deletion_log$uuid)\n\nreview_of_cleaning &lt;- review_cleaning(raw_dataset = my_raw_dataset,\n                                      raw_dataset_uuid_column = \"X_uuid\", \n                                      clean_dataset = exercise3_clean_dataset,\n                                      clean_dataset_uuid_column = \"X_uuid\",\n                                      cleaning_log = exercise3_log_no_deletion, \n                                      cleaning_log_uuid_column = \"uuid\",\n                                      cleaning_log_question_column = \"question\",\n                                      cleaning_log_new_value_column = \"new_value\",\n                                      cleaning_log_change_type_column = \"change_type\", \n                                      cleaning_log_old_value_column = \"old_value\", \n                                      deletion_log = exercise3_deletion_log, \n                                      deletion_log_uuid_column = \"uuid\"\n)",
    "crumbs": [
      "Cleaning session 2",
      "04 - Ejercicios (2)"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-01-checks.html",
    "href": "01-cleaning/01-cleaning-01-checks.html",
    "title": "01 - Verificaciones",
    "section": "",
    "text": "En esta sección, se presentan ciertas herramientas para la verificación de un conjunto de datos.\n\n\nlibrary(cleaningtools)\nlibrary(dplyr)\n\nmy_raw_dataset &lt;- cleaningtools::cleaningtools_raw_data\nmy_kobo_survey &lt;- cleaningtools::cleaningtools_survey\nmy_kobo_choice &lt;- cleaningtools::cleaningtools_choices\n\n\n\n\n\n\n\ncheck_*\n\n\n\n\nLas funciones de tipo check_* marcarán valores basándose en una verificación específica. Retornarán estos valores en un registro. Una función check_* devolverá una lista: el conjunto de datos verificado y el registro.\nLas funciones check_* solo se utilizan durante las etapas de limpieza.\n\n\n\n\nmy_log1 &lt;- my_raw_dataset %&gt;% \n  check_outliers(uuid_column = \"X_uuid\")\n\nEn este ejemplo, la salida será:\n\n\nchecked_dataset: el conjunto de datos original (con variables adicionales si es necesario)\n\npotential_outliers: un registro de posibles valores atípicos.\n\n\ntypeof(my_log1)\n\n[1] \"list\"\n\nmy_log1 %&gt;% \n  names()\n\n[1] \"checked_dataset\"    \"potential_outliers\"\n\n\nEl registro tiene al menos 4 columnas:\n\n\nuuid: el identificador único de la encuesta\n\nissue: el problema que se esta señalando\n\nquestion: el nombre de la variable en el conjunto de datos\n\nold_value: el valor que se está señalando\n\n\nmy_log1$potential_outliers %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\nuuid\nissue\nquestion\nold_value\n\n\n\nb5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06\noutlier (normal distribution)\nage_respondent_r\n86\n\n\n956b5ed0-5a62-41b7-aec3-af93fbc5b494\noutlier (normal distribution)\nage_respondent_r\n84\n\n\n97ad6294-30c6-454e-a0b3-42126415b767\noutlier (log distribution)\nage_respondent_r\n18\n\n\ne005e719-57c4-44a3-ac2f-5d6d1ff68831\noutlier (log distribution)\nage_respondent_r\n18\n\n\nc9aaa542-118f-4e42-93de-fb0916572541\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n48e8896b-d1be-4600-8839-2d8b994ebcfb\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nSe considerán como atípicos valores con +/- 3 deviaciones estándar de la media.\nSi asumimos una distribución logarítmica, utilizamos la función log(x + 1).\n\n\n\nmy_log2 &lt;- my_raw_dataset %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\")\n\nmy_log2$duplicate_log %&gt;% \n  head()\n\n\n\n\nuuid\nold_value\nquestion\nissue\n\n\n\n\n\n\nDado que no hay duplicados, el registro está vacío.\n\n\n\n\n\n\n\nPipe-able\n\n\n\nEl marco se basa en 2 adjetivos, pipe-able e independiente. En el marco, las funciones de la misma familias deben ser encadenables (pipeable). En el siguiente caso, se encadenan 2 funciones check_*.\n\n\n\nmy_log3 &lt;- my_raw_dataset %&gt;% \n  check_outliers(uuid_column = \"X_uuid\") %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\")\n\n\nnames(my_log3)\n\n[1] \"checked_dataset\"    \"potential_outliers\" \"duplicate_log\"     \n\n\n\nmy_log3$potential_outliers %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\nuuid\nissue\nquestion\nold_value\n\n\n\nb5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06\noutlier (normal distribution)\nage_respondent_r\n86\n\n\n956b5ed0-5a62-41b7-aec3-af93fbc5b494\noutlier (normal distribution)\nage_respondent_r\n84\n\n\n97ad6294-30c6-454e-a0b3-42126415b767\noutlier (log distribution)\nage_respondent_r\n18\n\n\ne005e719-57c4-44a3-ac2f-5d6d1ff68831\noutlier (log distribution)\nage_respondent_r\n18\n\n\nc9aaa542-118f-4e42-93de-fb0916572541\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n48e8896b-d1be-4600-8839-2d8b994ebcfb\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n\n\n\n\n\nmy_log3$duplicate_log %&gt;% \n  head()\n\n\n\n\nuuid\nold_value\nquestion\nissue\n\n\n\n\n\n\n\nEste es un ejemplo de verificaciones adicionales que existen.\n\nmore_logs &lt;- my_raw_dataset %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\") %&gt;% \n  check_soft_duplicates(uuid_column = \"X_uuid\", kobo_survey = my_kobo_survey, sm_separator = \".\") %&gt;%\n  check_outliers(uuid_column = \"X_uuid\") %&gt;%\n  check_value(uuid_column = \"X_uuid\")",
    "crumbs": [
      "Cleaning session 1",
      "01 - Verificaciones"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-01-checks.html#check_outliers",
    "href": "01-cleaning/01-cleaning-01-checks.html#check_outliers",
    "title": "01 - Verificaciones",
    "section": "",
    "text": "my_log1 &lt;- my_raw_dataset %&gt;% \n  check_outliers(uuid_column = \"X_uuid\")\n\nEn este ejemplo, la salida será:\n\n\nchecked_dataset: el conjunto de datos original (con variables adicionales si es necesario)\n\npotential_outliers: un registro de posibles valores atípicos.\n\n\ntypeof(my_log1)\n\n[1] \"list\"\n\nmy_log1 %&gt;% \n  names()\n\n[1] \"checked_dataset\"    \"potential_outliers\"\n\n\nEl registro tiene al menos 4 columnas:\n\n\nuuid: el identificador único de la encuesta\n\nissue: el problema que se esta señalando\n\nquestion: el nombre de la variable en el conjunto de datos\n\nold_value: el valor que se está señalando\n\n\nmy_log1$potential_outliers %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\nuuid\nissue\nquestion\nold_value\n\n\n\nb5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06\noutlier (normal distribution)\nage_respondent_r\n86\n\n\n956b5ed0-5a62-41b7-aec3-af93fbc5b494\noutlier (normal distribution)\nage_respondent_r\n84\n\n\n97ad6294-30c6-454e-a0b3-42126415b767\noutlier (log distribution)\nage_respondent_r\n18\n\n\ne005e719-57c4-44a3-ac2f-5d6d1ff68831\noutlier (log distribution)\nage_respondent_r\n18\n\n\nc9aaa542-118f-4e42-93de-fb0916572541\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n48e8896b-d1be-4600-8839-2d8b994ebcfb\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nSe considerán como atípicos valores con +/- 3 deviaciones estándar de la media.\nSi asumimos una distribución logarítmica, utilizamos la función log(x + 1).",
    "crumbs": [
      "Cleaning session 1",
      "01 - Verificaciones"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-01-checks.html#check_duplicate",
    "href": "01-cleaning/01-cleaning-01-checks.html#check_duplicate",
    "title": "01 - Verificaciones",
    "section": "",
    "text": "my_log2 &lt;- my_raw_dataset %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\")\n\nmy_log2$duplicate_log %&gt;% \n  head()\n\n\n\n\nuuid\nold_value\nquestion\nissue\n\n\n\n\n\n\nDado que no hay duplicados, el registro está vacío.",
    "crumbs": [
      "Cleaning session 1",
      "01 - Verificaciones"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-01-checks.html#pipe-able",
    "href": "01-cleaning/01-cleaning-01-checks.html#pipe-able",
    "title": "01 - Verificaciones",
    "section": "",
    "text": "Pipe-able\n\n\n\nEl marco se basa en 2 adjetivos, pipe-able e independiente. En el marco, las funciones de la misma familias deben ser encadenables (pipeable). En el siguiente caso, se encadenan 2 funciones check_*.\n\n\n\nmy_log3 &lt;- my_raw_dataset %&gt;% \n  check_outliers(uuid_column = \"X_uuid\") %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\")\n\n\nnames(my_log3)\n\n[1] \"checked_dataset\"    \"potential_outliers\" \"duplicate_log\"     \n\n\n\nmy_log3$potential_outliers %&gt;% \n  head()\n\n\n\n\n\n\n\n\n\n\nuuid\nissue\nquestion\nold_value\n\n\n\nb5b1d37a-e27a-4c35-a0f5-2cde9d6dfd06\noutlier (normal distribution)\nage_respondent_r\n86\n\n\n956b5ed0-5a62-41b7-aec3-af93fbc5b494\noutlier (normal distribution)\nage_respondent_r\n84\n\n\n97ad6294-30c6-454e-a0b3-42126415b767\noutlier (log distribution)\nage_respondent_r\n18\n\n\ne005e719-57c4-44a3-ac2f-5d6d1ff68831\noutlier (log distribution)\nage_respondent_r\n18\n\n\nc9aaa542-118f-4e42-93de-fb0916572541\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n48e8896b-d1be-4600-8839-2d8b994ebcfb\noutlier (normal distribution)\nnum_hh_member\n19\n\n\n\n\n\n\n\nmy_log3$duplicate_log %&gt;% \n  head()\n\n\n\n\nuuid\nold_value\nquestion\nissue",
    "crumbs": [
      "Cleaning session 1",
      "01 - Verificaciones"
    ]
  },
  {
    "objectID": "01-cleaning/01-cleaning-01-checks.html#verificaciones-adicionales",
    "href": "01-cleaning/01-cleaning-01-checks.html#verificaciones-adicionales",
    "title": "01 - Verificaciones",
    "section": "",
    "text": "Este es un ejemplo de verificaciones adicionales que existen.\n\nmore_logs &lt;- my_raw_dataset %&gt;% \n  check_duplicate(uuid_column = \"X_uuid\") %&gt;% \n  check_soft_duplicates(uuid_column = \"X_uuid\", kobo_survey = my_kobo_survey, sm_separator = \".\") %&gt;%\n  check_outliers(uuid_column = \"X_uuid\") %&gt;%\n  check_value(uuid_column = \"X_uuid\")",
    "crumbs": [
      "Cleaning session 1",
      "01 - Verificaciones"
    ]
  }
]